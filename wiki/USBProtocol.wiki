#summary A description of the weather display USB protocol.
#labels Protocol,USB,Weatherstation

= Introduction =

First off, this protocol description is based on USB logs sniffed using [http://sourceforge.net/projects/usbsnoop/ SnoopyPro] while running the windows program EasyWeather that comes with the device. 

wwsr.c written by [http://www.pendec.dk/weatherstation2007.htm Michael Pendec] was my inspiration to understand further exactly how the protocol works. This program was in part generated by a perl scrip based on the USB logs, and didn't do everything that I wanted.

This was my first adventure with any USB communication, so this description might not get all the facts straight, if you find any errors please contact me.

= Basics =

  * All communication to the device is sent in 8 byte blocks.
  * When data is read, it is done in 32 byte blocks.
  * The layout of the memory can be found here MemoryMap.

= Reading data =

To read data from the device a CLASS_INTERFACE message containing 8 bytes is sent. These consist of 4 bytes which is repeated twice. This message specifies the 2 byte memory offset that data should be read from.

|| *Index* || *Byte* || *Comment* ||
|| 0       || 0xA1   || Indicates that this is a read operation. ||
|| 1	   || Offset high byte || The memory address to read from, high byte. ||
|| 2       || Offset low byte  || The memory address to read from, low byte.  ||
|| 3       || 0x20 || Indicates end of offset. ||
|| ...     || ... || The same bytes are repeated again. ||

Example (Read from offset 0x0040): 
{{{
Send:    a1  00  40  20  a1  00  40  20  

Receive: 64  00  64  80  a0  28  80  25  
         a0  28  80  25  03  36  00  05  
         6b  00  00  00  00  f4  01  12  
         00  00  00  00  00  00  00  00  
}}}

After this message has been sent we can now read 32 bytes from the device.

= Writing data =

There are two ways of writing data to the device. In bulk or one byte at a time.

== Writing a single byte ==

To write a single byte, we send an 8 byte message with the following layout.

|| *Index* || *Byte* || *Comment* ||
|| 0       || 0xA2   || Indicates that this is a write operation. ||
|| 1	   || Offset high byte || The memory address to write to, high byte. ||
|| 2       || Offset low byte  || The memory address to write to, low byte.  ||
|| 3       || 0x20 || Indicates end of offset. ||
|| 4       || 0xA2 || Indicates that this is a write operation. ||
|| 5       || Data || The byte to write. ||
|| 6       || 0x00 || ||
|| 7       || 0x20 || ||

Example (Write 0x01 to offset 0x0018, which sets the timezone to CET+1): 
{{{
Send:    a2  00  18  20  a2  01  00  20  

Receive: a5  a5  a5  a5  a5  a5  a5  a5  
}}}

== Writing in bulk ==

To write to the device, the exact same method as reading is used, except that the first byte is 0xA0 instead of 0xA1. And instead of reading 32 bytes, we write the 32 bytes we want to change at that memory address.

After the data has been written, we should read 8 bytes which should all be 0xA5, meaning the device acknowledges the write.

To further indicate to the device a setting has been changed, we should write 0xAA to offset 0x1A (using the single byte method described above), which in turn is also acknowledged by an 8 byte 0xA5 message.

Example (Write 32 bytes of data to offset 0x0040):
{{{
Send:    a0  00  40  20  a0  00  40  20  
Send:    64  00  64  80  a0  28  80  25  
Send:    a0  28  80  25  03  36  00  05
Send:    6b  00  00  00  00  f4  01  12  
Send:    00  00  00  00  00  00  00  00  

Receive: a5  a5  a5  a5  a5  a5  a5  a5  
}}}